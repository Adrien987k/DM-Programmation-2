\documentclass{article}

\usepackage[utf8x]{inputenc} % accents
\usepackage[T1]{fontenc}      % caractères français
\usepackage{geometry}         % marges
\usepackage[french]{babel}  % langue
\usepackage{graphicx}         % images
\usepackage{verbatim}         % texte préformaté
\usepackage{bussproofs}       % proofs
\usepackage[cache=false]{minted}         % source code

\title{DM de programmation 2}
\author{Adrien Bardes}
\date{30 mars 2018}

\begin{document}

\maketitle

\section{La spécification de Mini-Ml}

\paragraph{Question 1.}

\begin{prooftree}
\def\fCenter{ \vdash\ }
\Axiom$\Gamma \fCenter n : int$
\UnaryInf$\Gamma \fCenter succ n : int$
\end{prooftree}

\begin{prooftree}
\def\fCenter{ \vdash\ }
\Axiom$\Gamma \fCenter n : int$
\UnaryInf$\Gamma \fCenter pred n : int$
\end{prooftree}


\paragraph{Question 2.}

\begin{minted}{ocaml}

let plus_body = fun n -> fun m -> 
  let n = fst c in
  let m = snd c in
  if n = 0 then n2 else
  if m = 0 then n1 else
  plus (pred n, succ m)

let rec plus = plus_body in plus


let time_body = fun n -> fun m ->
  if n = 0 then 0 else
  if m = 0 then 0 else
  time (plus(n, m), pred m)

let rec time = time_body in time

\end{minted}

\paragraph{Question 3.}

\begin{minted}{ocaml}

let rec f = fun x ->
  if x = 0 then 1 else
  time (x, f (x - 1))

\end{minted}

%TODO arbre de dérivation

\paragraph{Question 4.}

\begin{minted}{ocaml}

let x = fst ((fun n -> fun m -> (n, m)) 2 3) in x

\end{minted}

\paragraph{Question 5.}

Le typage des expression assure l'absence de plantage du à un mauvais typage
lors de l'exécution d'un programme

\paragraph{Question 6.}

En Ocaml, toutes les expressions sont des valeurs. Par exemple dans le code suivant, f est une valeur :
\begin{minted}{ocaml}
let rec f x = if x = 0 then 0 else f (x -1)
\end{minted}

\paragraph{Question 7.}

Sans les opérateurs de comparaison $\le$ et $\ge$ il n'est pas possible d'implémenter $pred$ en Mini-Ml.

\paragraph{Question 8.}



\paragraph{Question 9.}

L'opérateur $\not\equiv$ effectue un test sur les types des deux élements comparés. On a $a \not\equiv b$ si et seulement si $a$ et $b$ sont de type différents ou $a$ et $b$ sont du même type mais pas la même valeur.


\section{Implémentation de Mini-ML}

\paragraph{Question 10.}

%Let of var * ty option * expr loc
%let x^A = u
%let rec x^A = u
%LetRec of var * ty option * expr loc

\def\fCenter{ \mbox{ $\vdash$\ }}

\begin{figure}[!t]
\centering
\caption{La commande Let}
\label{Tux}
\end{figure}

\begin{prooftree}
\AxiomC{$\Gamma \vdash t : A$}
\UnaryInfC{$\Gamma \fCenter \textbf{let}\ x^A = t$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \textbf{let}\ x = \textbf{fix}\ (\lambda x^A .t)$}
\UnaryInfC{$\Gamma \vdash \textbf{let\ rec}\ x^A = t$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$t \hookrightarrow t'$}
\UnaryInfC{$\textbf{let}\ x = t\ \hookrightarrow \textbf{let}\ x = t'$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$$}
\UnaryInfC{$\textbf{let\ rec}\ x^A = t \hookrightarrow \textbf{fix}\ (\lambda x^A .t)$}
\end{prooftree}

\paragraph{Question 11.}

Un programme Mini-ML est une suite de commandes.

\paragraph{Question 12.}

$\Gamma, let x = t$ ==> $\Gamma, let x = t in x$
$\Gamma, let rec x = t$ ==> $let rec x = t in x$

\paragraph{Question 13.}

\begin{prooftree}
\AxiomC{$\Gamma, x : \textbf{bool}$}
\AxiomC{$\Gamma, y : \textbf{bool}$}
\BinaryInfC{$\Gamma, x\ \&\& \ y : \textbf{bool}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$x \hookrightarrow \textbf{true}$}
\AxiomC{$y \hookrightarrow \textbf{true}$}
\BinaryInfC{$x\ \&\& \ y \hookrightarrow \textbf{true}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$x \hookrightarrow \textbf{false}$}
\UnaryInfC{$x\ \&\& \ y \hookrightarrow \textbf{false}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$y \hookrightarrow \textbf{false}$}
\UnaryInfC{$x\ \&\& \ y \hookrightarrow \textbf{false}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma, x : \textbf{nat}$}
\AxiomC{$\Gamma, y : \textbf{nat}$}
\BinaryInfC{$\Gamma, x + y : \textbf{nat}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\textbf{plus}\ x \ y$}
\UnaryInfC{$x + y$}
\end{prooftree}

\paragraph{Question 14.}

Le let rec in est directement traduit en un fixpoint...

\end{document}
